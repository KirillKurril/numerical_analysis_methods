def euler(xdot, N, y0, y_diff):
    ydots = [y0]
    h = xdot / N
    for i in range(N):
        x = i * h
        y = ydots[-1]
        ydots += [y + h * y_diff(x, y)]
    return ydots


def modified_euler(xdot, N, y0, y_diff):
    ydots = [y0]
    h = xdot / N
    for i in range(N):
        x = i * h
        y = ydots[-1]
        ydots += [y + h * y_diff(x + h / 2, y + h / 2 * y_diff(x, y))]
    return ydots


def runge_kutta(xdot, N, y0, y_diff):
    ydots = [y0]
    h = xdot / N
    for i in range(N):
        x = i * h
        y = ydots[-1]
        K1 = h * y_diff(x, y)
        K2 = h * y_diff(x + h / 2, y + K1 / 2)
        K3 = h * y_diff(x + h / 2, y + K2 / 2)
        K4 = h * y_diff(x + h, y + K3)
        ydots += [y + 1/6 * (K1 + 2*K2 + 2*K3 + K4)]
    return ydots


def get_value_at_point(method, x, y0, y_diff, eps):
    n = 1
    old_dots, new_dots = method(x, n, y0, y_diff), method(x, 2 * n, y0, y_diff)
    while max(abs(new_dots[2*i] - old_dots[i]) for i in range(n + 1)) > eps:
        n *= 2
        old_dots, new_dots = method(x, n, y0, y_diff), method(x, 2 * n, y0, y_diff)
    return new_dots[-1], 2 * n


def create_y_dots(method, xdots, y0, y_diff, eps):
    ydots = []
    maxn = 0
    midn = []
    for x in xdots:
        y, n = get_value_at_point(method, x, y0, y_diff, eps)
        ydots.append(y)
        maxn = max(maxn, n)
        midn += [n]
    midn = sum(midn) / len(xdots)
    return ydots, midn, maxn





# Алгоритм метода Эйлера, реализованный в данном коде, выглядит следующим образом:

# Создается список ydots, начальное значение которого равно y0. В этот список будут добавляться значения функции y на каждом шаге.

# Вычисляется шаг h, который представляет собой длину каждого интервала исходного интервала [0, xdot] исходя из количества шагов N.

# Запускается цикл for с переменной i, который выполняется N раз.

# Внутри цикла:

# Вычисляется значение x на текущем шаге как i * h.
# Получается текущее значение y из последнего элемента списка ydots.
# Вычисляется значение производной функции y относительно x с помощью функции y_diff(x, y).
# Вычисляется новое значение y на текущем шаге, используя метод Эйлера: y + h * y_diff(x, y).
# Новое значение y добавляется в список ydots.
# По завершении цикла, список ydots содержит значения функции y на каждом шаге.

# Функция возвращает список ydots.



#Модифицированный метод Эйлера вычисляет значения рекуррентно и не в начале каждого 
#отрезка-шага а в его середине 


#Метод Рунге-Кутты 
# В методе эйлера, вычисляя следующее значение функции через ряд тейлора
# y(x) = y(x0) + (x-x0)y'(x0) + (x-x0)^2/2 * y"(x0) + ...
# , задействуя первую производную мы понимаем 
# что при использовании только первый двух членов получается очень большая погрешность,
# поэтому нам нужно как-то найти остальные члены ряда тейлора 
# для этого нужно как-то вычислить производные старших порядков для исходного уравнения 

# теперь приращение дельта у будем вычислять по формуле
# Δy = (k1 + 2*k2 + 2*k3 + k4) / 6 -- будем брать формулу четвертого порядка 
# как их считать есть в коде



# каждый интервал между двумя точками рабивается на еще более мелкие части 
# и уже к каждой из которых применяется метод 
# сделано это для соблюдения погрежности








